# 下位机通讯协议详解（适用于上位机开发者）

## 1. 通讯概述

STM32下位机（RoboMaster A型开发板）与ROS2上位机之间通过UART串口建立通信，实现双向数据传输。

### 1.1 基本参数
- **通信接口**: UART3
- **波特率**: 115200bps
- **数据位**: 8位
- **停止位**: 1位
- **校验位**: 无校验
- **流控制**: 无硬件流控

### 1.2 通信方向
- **下位机 → 上位机**: 系统状态数据（蛇形关节电机位置和速度、4个IMU的欧拉角数据）
- **上位机 → 下位机**: 控制命令（电机目标位置和速度、复位标志）

### 1.3 发送频率
- 下位机以**60Hz**频率（约每17ms一次）向上位机发送状态数据
- 频率通过`TASK/time_task.c`中的`MOTOR_IMU_DATA_SEND_PERIOD`常量(17)控制

## 2. 下位机→上位机：数据帧格式

### 2.1 总体结构
下位机向上位机发送的数据帧总长度为**113字节**，由以下部分组成：

| 部分 | 大小 | 内容 | 字节顺序 |
|------|------|------|----------|
| **帧头** | 2字节 | 固定值`0xAA 0x55` | - |
| **数据长度** | 1字节 | `0x6C` (十进制108) | - |
| **数据段** | 108字节 | 见下表详细说明 | 取决于数据类型 |
| **CRC校验** | 2字节 | Modbus CRC-16 | 大端格式(高字节在前) |

### 2.2 数据段结构 (108字节)

| 部分 | 偏移量 | 大小 | 数据类型 | 字节顺序 | 内容说明 |
|------|--------|------|----------|----------|----------|
| 关节位置 | 0-47 | 48字节 | 12个int32_t | 大端格式 | 蛇形机器人12个关节电机的当前位置(`currentPosition_snake[12]`) |
| 关节速度 | 48-59 | 12字节 | 12个int8_t | - | 蛇形机器人12个关节电机的当前速度(`currentSpeed_snake[12]`) |
| IMU 1数据 | 60-71 | 12字节 | 3个float | 小端格式 | USART2 IMU的pitch, roll, yaw角度，通过`get_eular2()`获取 |
| IMU 2数据 | 72-83 | 12字节 | 3个float | 小端格式 | UART7 IMU的pitch, roll, yaw角度，通过`get_eular7()`获取 |
| IMU 3数据 | 84-95 | 12字节 | 3个float | 小端格式 | UART8 IMU的pitch, roll, yaw角度，通过`get_eular8()`获取 |
| IMU 4数据 | 96-107 | 12字节 | 3个float | 小端格式 | USART6 IMU的pitch, roll, yaw角度，通过`get_eular6()`获取 |

> **重要说明**：
> 1. **最近变更**：最近代码更新移除了GM6020和C610电机位置数据（各4字节），使得数据段从116字节减少到108字节
> 2. **大端格式**：对于int32_t值，如0x12345678，发送顺序为：0x12, 0x34, 0x56, 0x78（高字节在前）
> 3. **小端格式**：STM32上的float数据按照小端格式存储和发送，上位机解析时需注意

### 2.3 代码实现
下位机发送数据帧的关键代码（来自`HARDWARE/uart3.c`的`TX2_Send_Motor_IMU_Data`函数）：

```c
// 1. 添加帧头 0xAA 0x55
tx_buffer[tx_index++] = 0xAA;
tx_buffer[tx_index++] = 0x55;

// 2. 数据长度位置先预留，等计算完毕后再填充
uint8_t length_index = tx_index;
tx_index++;

// 3. 添加12个电机的位置数据 (48字节) - 大端格式
for (int i = 0; i < 12; i++) {
    tx_buffer[tx_index++] = (currentPosition_snake[i] >> 24) & 0xFF;
    tx_buffer[tx_index++] = (currentPosition_snake[i] >> 16) & 0xFF;
    tx_buffer[tx_index++] = (currentPosition_snake[i] >> 8) & 0xFF;
    tx_buffer[tx_index++] = currentPosition_snake[i] & 0xFF;
}

// 4. 添加12个电机的速度数据 (12字节)
for (int i = 0; i < 12; i++) {
    tx_buffer[tx_index++] = currentSpeed_snake[i] & 0xFF;
}

// 5. 添加4个IMU的欧拉角数据 (4*3*4=48字节) - 小端格式
// USART2 IMU数据
get_eular2(temp_eular);
for (int i = 0; i < 3; i++) {
    uint8_t *p = (uint8_t*)&temp_eular[i]; // 将浮点数转为4字节
    tx_buffer[tx_index++] = p[0];
    tx_buffer[tx_index++] = p[1];
    tx_buffer[tx_index++] = p[2];
    tx_buffer[tx_index++] = p[3];
}
// ... 类似代码重复三次，分别获取UART7、UART8和USART6的IMU数据 ...

// 6. 计算数据长度并填充到之前预留的位置
data_length = tx_index - length_index - 1;
tx_buffer[length_index] = data_length;

// 7. 计算CRC16校验值并添加到缓冲区末尾
crc16 = calc_crc16_modbus(tx_buffer, tx_index);
tx_buffer[tx_index++] = (crc16 >> 8) & 0xFF; // CRC高字节
tx_buffer[tx_index++] = crc16 & 0xFF;        // CRC低字节
```

## 3. 上位机→下位机：命令帧格式

### 3.1 总体结构
上位机向下位机发送的命令帧总长度为**81字节**，由以下部分组成：

| 部分 | 大小 | 内容 | 说明 |
|------|------|------|------|
| **帧头** | 2字节 | 固定值`0xAA 0x55` | - |
| **地址** | 1字节 | `0x01` | 控制器地址 |
| **长度** | 1字节 | `0x4B` (十进制75) | 从功能码开始到CRC之前的数据长度 |
| **功能码** | 1字节 | `0x31` | 表示电机控制命令 |
| **电机数量** | 1字节 | `0x10` | 要控制的电机数量 |
| **控制数据** | 69字节 | 见下表详细说明 | 电机控制值 |
| **控制标志** | 1字节 | 0/1/6/9 | 复位控制：0=无操作,1=复位,6=禁用,9=启用 |
| **CRC校验** | 2字节 | Modbus CRC-16 | 大端格式(高字节在前) |

### 3.2 控制数据结构 (69字节)

| 部分 | 大小 | 格式 | 内容说明 |
|------|------|------|----------|
| 蛇形机器人控制 | 60字节 | 12组(1字节速度+4字节位置) | 12个电机的速度和位置控制值 |
| GM6020控制 | 3字节 | 2字节位置+1字节填充 | GM6020电机位置控制值 |
| C610控制 | 3字节 | 2字节位置+1字节填充 | C610电机位置控制值 |
| STS3032控制 | 3字节 | 2字节位置+1字节填充 | STS3032舵机位置控制值 |

下位机通过`USART3_IRQHandler`中断函数接收和处理上位机发送的命令。关键解析代码：

```c
// 蛇形机器人电机控制数据解析
uint16_t offset = 6; // 数据从第6位开始
for (uint8_t i = 0; i < 12; ++i) {
    snake_motor_speed_control[i] = rx_buffer[offset++] * 65536 / 60; // 将RPM转换为pulse/s
    snake_motor_position_control[i] = (rx_buffer[offset] << 24) | 
                                      (rx_buffer[offset + 1] << 16) | 
                                      (rx_buffer[offset + 2] << 8) | 
                                       rx_buffer[offset + 3];
    offset += 4;
}

// 机械爪电机控制数据解析
offset += 1;  // 跳过一个字节
gripper_gm6020_position_control = (rx_buffer[offset] << 8) | rx_buffer[offset + 1];
offset += 3;  // 包括1字节填充
gripper_c610_position_control = (rx_buffer[offset] << 8) | rx_buffer[offset + 1];
offset += 3;  // 包括1字节填充
gripper_sts3032_position_control = (rx_buffer[offset] << 8) | rx_buffer[offset + 1];
offset += 3;  // 包括1字节填充

// 控制标志
reset_control = rx_buffer[offset++];
```

## 4. CRC校验算法

下位机使用Modbus CRC-16算法计算校验值，初始值为0xFFFF。C语言实现如下（来自`uart3.c`）：

```c
uint16_t calc_crc16_modbus(uint8_t *data, uint16_t length) {
    uint16_t crc = 0xFFFF; // 初始值
    for (uint16_t i = 0; i < length; ++i) {
        uint8_t pos = crc ^ data[i];
        crc = crc16_table[pos] ^ (crc >> 8);
    }
    return crc;
}
```

其中`crc16_table`是预定义的CRC查找表（为简化文档已省略）。此校验计算范围为从帧头(0xAA)开始，直到数据段末尾的所有字节。

## 5. 上位机实现指南

### 5.1 数据接收实现

上位机接收下位机数据的推荐流程：

1. **接收缓冲区管理**：
   - 维护足够大的环形缓冲区（至少256字节）
   - 检测0xAA 0x55帧头来识别数据包起始
   - 根据长度字段确定完整数据包大小

2. **解析示例（C++）**：
```cpp
// 解析int32_t（大端格式）
int32_t parseInt32BE(const uint8_t* data, size_t offset) {
    return (data[offset] << 24) | (data[offset+1] << 16) | 
           (data[offset+2] << 8) | data[offset+3];
}

// 解析float（小端格式 - STM32是小端架构）
float parseFloat(const uint8_t* data, size_t offset) {
    float result;
    memcpy(&result, &data[offset], sizeof(float));
    return result;
}

// 解析完整数据包
bool parsePacket(const std::vector<uint8_t>& packet) {
    // 验证帧头
    if (packet[0] != 0xAA || packet[1] != 0x55) {
        return false;
    }
    
    // 获取长度并检查数据包完整性
    uint8_t dataLength = packet[2];
    if (packet.size() < dataLength + 5) { // 帧头(2) + 长度(1) + 数据(dataLength) + CRC(2)
        return false;
    }
    
    // 验证CRC
    uint16_t receivedCrc = (packet[dataLength+3] << 8) | packet[dataLength+4];
    uint16_t calculatedCrc = calculateCRC16Modbus(packet.data(), dataLength+3);
    if (receivedCrc != calculatedCrc) {
        return false;
    }
    
    // 数据解析
    std::vector<int32_t> jointPositions(12);
    std::vector<int8_t> jointVelocities(12);
    std::vector<std::array<float, 3>> imuData(4); // 4个IMU的欧拉角数据
    
    size_t offset = 3; // 跳过帧头和长度字段
    
    // 解析关节位置（12 * int32_t，大端格式）
    for (int i = 0; i < 12; i++) {
        jointPositions[i] = parseInt32BE(packet.data(), offset);
        offset += 4;
    }
    
    // 解析关节速度（12 * int8_t）
    for (int i = 0; i < 12; i++) {
        jointVelocities[i] = static_cast<int8_t>(packet[offset++]);
    }
    
    // 解析IMU数据（4个IMU，每个3个float，小端格式）
    for (int imu = 0; imu < 4; imu++) {
        for (int axis = 0; axis < 3; axis++) {
            imuData[imu][axis] = parseFloat(packet.data(), offset);
            offset += 4;
        }
    }
    
    // 使用解析得到的数据
    // ...
    
    return true;
}
```

3. **Python实现示例**:
```python
import struct

def parse_int32_be(data, offset):
    """解析大端格式的int32_t"""
    return (data[offset] << 24) | (data[offset+1] << 16) | \
           (data[offset+2] << 8) | data[offset+3]

def parse_float(data, offset):
    """解析小端格式的float"""
    return struct.unpack('<f', bytes(data[offset:offset+4]))[0]

def parse_packet(packet):
    """解析完整数据包"""
    # 验证帧头
    if packet[0] != 0xAA or packet[1] != 0x55:
        return None
    
    # 获取长度并检查数据包完整性
    data_length = packet[2]
    if len(packet) < data_length + 5:  # 帧头(2) + 长度(1) + 数据(data_length) + CRC(2)
        return None
    
    # 验证CRC
    received_crc = (packet[data_length+3] << 8) | packet[data_length+4]
    calculated_crc = calculate_crc16_modbus(packet[:data_length+3])
    if received_crc != calculated_crc:
        return None
    
    # 初始化结果
    result = {
        'joint_positions': [0] * 12,
        'joint_velocities': [0] * 12,
        'imu_data': [{'pitch': 0, 'roll': 0, 'yaw': 0} for _ in range(4)]
    }
    
    offset = 3  # 跳过帧头和长度字段
    
    # 解析关节位置（12 * int32_t，大端格式）
    for i in range(12):
        result['joint_positions'][i] = parse_int32_be(packet, offset)
        offset += 4
    
    # 解析关节速度（12 * int8_t）
    for i in range(12):
        result['joint_velocities'][i] = packet[offset]
        if result['joint_velocities'][i] > 127:  # 处理有符号8位整数
            result['joint_velocities'][i] -= 256
        offset += 1
    
    # 解析IMU数据（4个IMU，每个3个float，小端格式）
    axes = ['pitch', 'roll', 'yaw']
    for imu in range(4):
        for axis_idx in range(3):
            result['imu_data'][imu][axes[axis_idx]] = parse_float(packet, offset)
            offset += 4
    
    return result
```

### 5.2 ROS2集成

将下位机数据集成到ROS2系统的推荐方法：

1. **创建自定义消息**:
```
# SnakeRobotState.msg
std_msgs/Header header
int32[12] joint_positions
int8[12] joint_velocities
geometry_msgs/Vector3[4] imu_euler_angles  # 4个IMU的欧拉角
```

2. **串口节点实现**:
```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
import serial
import struct
import threading
from snake_robot_msgs.msg import SnakeRobotState
from geometry_msgs.msg import Vector3

class SnakeRobotSerialNode(Node):
    def __init__(self):
        super().__init__('snake_robot_serial_node')
        
        # 声明参数
        self.declare_parameter('port', '/dev/ttyUSB0')
        self.declare_parameter('baud_rate', 115200)
        
        # 获取参数
        port = self.get_parameter('port').get_parameter_value().string_value
        baud_rate = self.get_parameter('baud_rate').get_parameter_value().integer_value
        
        # 创建发布器
        self.state_publisher = self.create_publisher(
            SnakeRobotState, 
            'snake_robot/state', 
            10)
        
        # 初始化串口
        try:
            self.serial = serial.Serial(
                port=port,
                baudrate=baud_rate,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                timeout=0.1
            )
            self.get_logger().info(f'成功连接到串口 {port} 波特率 {baud_rate}')
        except serial.SerialException as e:
            self.get_logger().error(f'无法打开串口: {e}')
            return
            
        # 启动读取线程
        self.running = True
        self.rx_thread = threading.Thread(target=self.read_serial)
        self.rx_thread.daemon = True
        self.rx_thread.start()
        
    def read_serial(self):
        """持续读取串口数据的线程"""
        buffer = bytearray()
        
        while self.running and rclpy.ok():
            try:
                if self.serial.in_waiting:
                    data = self.serial.read(self.serial.in_waiting)
                    buffer.extend(data)
                    
                    # 处理缓冲区中的所有完整数据包
                    while True:
                        # 查找帧头
                        start_idx = buffer.find(b'\xAA\x55')
                        if start_idx == -1:
                            # 没有找到帧头，清除部分数据避免缓冲区无限增长
                            if len(buffer) > 500:
                                buffer = buffer[-500:]
                            break
                        
                        # 调整缓冲区，丢弃帧头前的数据
                        if start_idx > 0:
                            buffer = buffer[start_idx:]
                        
                        # 检查长度字段是否已接收
                        if len(buffer) < 3:
                            break
                            
                        data_length = buffer[2]
                        total_length = data_length + 5  # 帧头(2) + 长度(1) + 数据段(data_length) + CRC(2)
                        
                        # 检查是否接收到完整数据包
                        if len(buffer) < total_length:
                            break
                            
                        # 提取数据包
                        packet = buffer[:total_length]
                        buffer = buffer[total_length:]
                        
                        # 解析数据包
                        result = self.parse_packet(packet)
                        if result:
                            self.publish_state(result)
                            
            except Exception as e:
                self.get_logger().error(f'串口读取错误: {e}')
                # 重新尝试建立连接
                try:
                    self.serial.close()
                    self.serial.open()
                except:
                    pass
                    
            # 短暂休眠避免CPU占用过高
            time.sleep(0.001)
    
    def parse_packet(self, packet):
        """解析数据包"""
        # 验证CRC
        received_crc = (packet[-2] << 8) | packet[-1]
        calculated_crc = self.calculate_crc16_modbus(packet[:-2])
        if received_crc != calculated_crc:
            self.get_logger().warn('CRC校验失败')
            return None
            
        # 初始化结果字典
        result = {
            'joint_positions': [],
            'joint_velocities': [],
            'imu_data': []
        }
        
        # 解析数据
        offset = 3  # 跳过帧头和长度字段
        
        # 解析关节位置
        for _ in range(12):
            pos = (packet[offset] << 24) | (packet[offset+1] << 16) | \
                  (packet[offset+2] << 8) | packet[offset+3]
            # 处理有符号整数
            if pos & 0x80000000:
                pos -= 0x100000000
            result['joint_positions'].append(pos)
            offset += 4
            
        # 解析关节速度
        for _ in range(12):
            vel = packet[offset]
            if vel > 127:
                vel -= 256
            result['joint_velocities'].append(vel)
            offset += 1
            
        # 解析4个IMU数据
        for _ in range(4):
            imu_values = []
            for _ in range(3):  # pitch, roll, yaw
                val = struct.unpack('<f', packet[offset:offset+4])[0]
                imu_values.append(val)
                offset += 4
            result['imu_data'].append(imu_values)
            
        return result
        
    def publish_state(self, data):
        """发布机器人状态消息"""
        msg = SnakeRobotState()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = 'snake_robot_base'
        
        # 填充关节位置和速度
        msg.joint_positions = data['joint_positions']
        msg.joint_velocities = data['joint_velocities']
        
        # 填充IMU数据
        for i, imu_data in enumerate(data['imu_data']):
            euler = Vector3()
            euler.x = imu_data[0]  # pitch
            euler.y = imu_data[1]  # roll
            euler.z = imu_data[2]  # yaw
            msg.imu_euler_angles[i] = euler
            
        # 发布消息
        self.state_publisher.publish(msg)
    
    def calculate_crc16_modbus(self, data):
        """计算Modbus CRC-16校验和"""
        crc = 0xFFFF
        for byte in data:
            crc = ((crc >> 8) & 0xFF) | ((crc << 8) & 0xFF00)
            crc ^= byte
            crc ^= (crc & 0xFF) >> 4
            crc ^= ((crc << 8) & 0xFF00) >> 4
            crc ^= ((crc & 0xFF) << 4) & 0xFF00
        return crc
        
    def destroy_node(self):
        """清理资源"""
        self.running = False
        if hasattr(self, 'rx_thread'):
            self.rx_thread.join(timeout=1.0)
        if hasattr(self, 'serial') and self.serial.is_open:
            self.serial.close()
        super().destroy_node()

def main(args=None):
    rclpy.init(args=args)
    node = SnakeRobotSerialNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## 6. 通讯变更历史与注意事项

### 6.1 重要变更

1. **数据格式变化**:
   - 最近的代码修改移除了GM6020和C610电机位置数据（各4字节）
   - 数据段长度从116字节减少到108字节
   - 总帧长从121字节减少到113字节

2. **发送频率调整**:
   - 发送频率从20Hz增加到60Hz（周期从50ms改为17ms）

### 6.2 关键注意事项

1. **字节序问题**:
   - int32_t数据使用大端格式发送（高字节在前）
   - float数据使用STM32原生的小端格式发送

2. **CRC校验范围**:
   - CRC校验计算范围包含从帧头开始到数据段末尾的所有字节
   - 返回的CRC值按大端格式（高字节在前）发送

3. **浮点数精度**:
   - IMU欧拉角数据为STM32上的IEEE 754标准单精度浮点数
   - 角度单位为弧度（而非角度）

4. **数据缓冲管理**:
   - 上位机需维护足够大的接收缓冲区（建议至少256字节）
   - 应使用帧头检测和长度验证确保数据包完整性

## 7. 调试与验证

### 7.1 调试工具

1. **串口分析器**:
   - 推荐使用Serial Monitor/Wireshark等工具监控数据流
   - 记录和分析每帧数据格式，确认是否符合预期

2. **数据可视化**:
   - 建议开发简单的数据可视化工具
   - 将解析后的IMU欧拉角数据实时绘制，验证解析正确性

### 7.2 验证流程

1. **连接验证**:
   - 确认串口连接正常，能持续接收到数据
   - 验证发送频率是否接近预期的60Hz

2. **数据完整性验证**:
   - 验证每帧数据包长度和帧格式
   - 确认CRC校验能否正确通过

3. **数据解析验证**:
   - 验证解析后的关节位置和速度值是否在合理范围内
   - 验证IMU欧拉角数据是否平滑变化且值在合理范围内

4. **回环测试**:
   - 向下位机发送控制命令，验证下位机是否正确执行
   - 观察电机位置变化是否符合预期

## 8. 参考资料

1. **STM32参考手册**:
   - 特别关注UART通信部分和字节序说明

2. **IEEE 754浮点数标准**:
   - 了解单精度浮点数的内存表示和字节序影响

3. **Modbus CRC-16算法**:
   - 参考标准Modbus CRC-16算法实现和验证方法
